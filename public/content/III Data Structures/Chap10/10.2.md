---
title: "10.2 Linked lists"
---

## 10.2-1

> Can you implement the dynamic-set operation $\text{INSERT}$ on a singly linked list in $O(1)$ time? How about $\text{DELETE}$?

- $\text{INSERT}$: can be implemented in constant time by prepending it to the list.

    ```cpp
    LIST-INSERT(L, x)
        x.next = L.head
        L.head = x
    ```

- $\text{DELETE}$: cannot be implemented in constant time, unless you pass to it as an argument the predecessor of the element you are deleting.

## 10.2-2

> Implement a stack using a singly linked list $L$. The operations $\text{PUSH}$ and $\text{POP}$ should still take $O(1)$ time.

```cpp
STACK-EMPTY(S)
    if L.head == NIL
        return TRUE
    else return FALSE
```

- $\text{PUSH}$: adds an element in the beginning of the list.

    ```cpp
    PUSH(S, x)
        LIST-INSERT(L, x)
    ```

- $\text{POP}$: removes the first element from the list.

    ```cpp
    POP(S)
        x = L.head
        LIST-DELETE(L, L.head)
        return x
    ```

## 10.2-3

> Implement a queue by a singly linked list $L$. The operations $\text{ENQUEUE}$ and $\text{DEQUEUE}$ should still take $O(1)$ time.

```cpp
QUEUE-EMPTY(Q)
    if L.head == NIL
        return TRUE
    else return FALSE
```

- $\text{ENQUEUE}$: inserts an element in the beginning of the list.

    ```cpp
    ENQUEUE(Q, x)
        if QUEUE-EMPTY(Q)
            Q.head = x
        else Q.tail.next = x
        Q.tail = x
        x.next = NIL
    ```

- $\text{DEQUEUE}$: removes an element from the end of the list. In this case we need to keep track of the last element of the list. We can do that with a sentinel.

    ```cpp
    DEQUEUE(Q)
        if QUEUE-EMPTY(Q)
            error "underflow"
        else
            if Q.head == Q.tail
                Q.tail = NIL
            Q.head = Q.head.next
            x = L.head
            LIST-DELETE(L, L.head)
            return x
    ```

## 10.2-4

> As written, each loop iteration in the $\text{LIST-SEARCH}^\prime$ procedure requires two tests: one for $x \ne L.nil$ and one for $x.key \ne k$. Show how to eliminate the test for $x \ne L.nil$ in each iteration.

```cpp
LIST-SEARCH'(L, k)
    x = L.nil.next
    L.nil.key = k
    while x.key != k
        x = x.next
    return x
```

## 10.2-5

> Implement the dictionary operations $\text{INSERT}$, $\text{DELETE}$, and $\text{SEARCH}$ using singly linked, circular lists. What are the running times of your procedures?

- $\text{INSERT}$: $O(n)$.

    ```
    LIST-INSERT''(L, x)
        x.next = L.nil.next
        L.nil.next = x
    ```

- $\text{DELETE}$: $O(n)$.

    ```
    LIST-DELETE''(L, x)
        prev = L.nil
        while prev.next.key != x
            if prev.next == L.nil
                error "element not exist"
            prev = prev.next
        prev.next = x.next
    ```

- $\text{SEARCH}$: $O(n)$.

    ```
    LIST-SEARCH''(L, x)
        L.nil
        x = L.nil.next
        while x.key != k
            x = x.next
        return x
    ```

## 10.2-6

> The dynamic-set operation $\text{UNION}$ takes two disjoint sets $S\_1$ and $S\_2$ as input, and it returns a set $S = S\_1 \cup S\_2$ consisting of all the elements of $S\_1$ and $S\_2$. The sets $S\_1$ and $S\_2$ are usually destroyed by the operation. Show how to support $\text{UNION}$ in $O(1)$ time using a suitable list data structure.

If both sets are a doubly linked lists, we just point link the last element of the first list to the first element in the second. If the implementation uses sentinels, we need to destroy one of them.

```cpp
LIST-UNION(L1, L2)
    L2.nil.next.prev = L1.nil.prev
    L1.nil.prev.next = L2.nil.next
    L2.nil.prev.next = L1.nil
    L1.nil.prev = L2.nil.prev
```

## 10.2-7

> Give a $\Theta(n)$-time nonrecursive procedure that reverses a singly linked list of $n$ elements. The procedure should use no more than constant storage beyond that needed for the list itself.

```cpp
LIST-REVERSE(L)
    if L.head == NIL
        error "empty list"
    else if L.head.next == NIL
        return
    else
        p1 = L.head.next
        L.head.next = NIL
        p2 = p1.next
        p1 = next = L.head
        while p2 != NIL
            p3 = p2.next
            p2.next = p1
            p1 = p2
            p2 = p3
        L.head = p1
```

## 10.2-8 $\star$

> Explain how to implement doubly linked lists using only one pointer value $x.np$ per item instead of the usual two ($next$ and $prev$). Assume all pointer values can be interpreted as $k$-bit integers, and define $x.np$ to be $x.np = x.next$ XOR $x.prev$, the $k$-bit "exclusive-or" of $x.next$ and $x.prev$. (The value $\text{NIL}$ is represented by $0$.) Be sure to describe what information you need to access the head of the list. Show how to implement the $\text{SEARCH}$, $\text{INSERT}$, and $\text{DELETE}$ operations on such a list. Also show how to reverse such a list in $O(1)$ time.

<div>
$$
\begin{aligned}
head.np &= next \\
tail.np &= prev \\
   next &= x.np \text{ XOR } prev \\
   prev &= x.np \text{ XOR } next \\
\end{aligned}
$$
</div>

- Reverse:

<div>
$$
\begin{aligned}
      head.np.np &= (head\text{ XOR }head.np.np)\text{ XOR }tail \\
      tail.np.np &= (tail\text{ XOR }tail.np.np)\text{ XOR }head \\
head.np, tail.np &= tail.np, head.np
\end{aligned}
$$
</div>
